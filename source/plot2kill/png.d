/* This PNG library is based on Adam Ruppe's PNG code, which he released into
 * the public domain.  Basically, I adapted it by stripping out everything
 * that I didn't need.  It's currently used for saving PNGs in the DFL port.
 *
 * This code is currently not considered part of the public API of plot2kill.
 *
 * License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module plot2kill.png;

version(dfl) {

package:

import plot2kill.util;
import core.stdc.stdlib : malloc, free;

// This function is by David Simcha 2010.

// Save an array of pixels in backwards BGR, bottom to top order to a PNG.
void writePngFromBitmapPixels(Pixel)
(Pixel[] pix, File handle, int width, int height) {
    immutable nPixels = width * height;
    enforce(pix.length == nPixels);

    ubyte[] rgbPix = (cast(ubyte*) malloc(nPixels * 4))[0..nPixels * 4];
    scope(exit) free(cast(void*) rgbPix);
    size_t copyIndex = 0;

    // We need to make the image right side up, not upside down like they are
    // for bitmaps.  We also need to make sure the byte order is rgb, not bgr,
    // and add an alpha channel.
    foreach(row; 0..height) {
        auto rowPix = pix[$ - (row + 1) * width..$ - row * width];

        foreach(p; rowPix) {
            rgbPix[copyIndex++] = p.r;
            rgbPix[copyIndex++] = p.g;
            rgbPix[copyIndex++] = p.b;
            rgbPix[copyIndex++] = 255;
        }
    }

    TrueColorImage png;
    png.width = width;
    png.height = height;
    png.data = rgbPix;

    auto pngData = writePng(pngFromImage(png));
    handle.rawWrite(pngData);
}


// The stuff below is by Adam D. Ruppe, 2009-2010, released into the public
// domain, adapted by David Simcha 2010.
import std.zlib;

// convenience for 32 bit per pixel RGBA images
struct TrueColorImage {
	int width;
	int height;
	ubyte[] data; // one byte per color entry, left to right, top to bottom, RGBA. So 32 bits per pixel
	// I believe this is, in memory, identical to Color[] data;
}

// Represents basic data about a png. If you just use the convenience structs above, you never actually need this.
struct PNGHeader {
	uint width; // in pixels
	uint height;
	ubyte depth = 8; // this is bits per color entry. For truecolor, 8 means RGBA each get 8 bits each. For indexed images, it is bits per pixel, so 8 means 256 color. It must be a power of two. 8 almost always works for me.
	ubyte type = 6; // 0 - greyscale, 2 - truecolor, 3 - indexed color, 4 - grey with alpha, 6 - true with alpha
	ubyte compressionMethod = 0; // should be zero
	ubyte filterMethod = 0; // should be zero
	ubyte interlaceMethod = 0; // bool. this code doesn't support interlacing.
}

// Ditto, but for truecolor images
PNG* pngFromImage(TrueColorImage i) {
	PNGHeader h;
	h.width = i.width;
	h.height = i.height;
	// FIXME: optimize it if it is greyscale or doesn't use alpha alpha

	auto png = blankPNG(h);
	addImageDatastreamToPng(i.data, png);

	return png;
}

// used when reading a png file
PNGHeader getHeader(PNG* p) {
	PNGHeader h;
	ubyte[] data = p.getChunk("IHDR").payload;

	int pos = 0;

	h.width |= data[pos++] << 24;
	h.width |= data[pos++] << 16;
	h.width |= data[pos++] << 8;
	h.width |= data[pos++] << 0;

	h.height |= data[pos++] << 24;
	h.height |= data[pos++] << 16;
	h.height |= data[pos++] << 8;
	h.height |= data[pos++] << 0;

	h.depth = data[pos++];
	h.type = data[pos++];
	h.compressionMethod = data[pos++];
	h.filterMethod = data[pos++];
	h.interlaceMethod = data[pos++];

	return h;
}


// PNG files are made out of a series of chunks
struct Chunk {
	uint size;
	ubyte[4] type;
	ubyte[] payload;
	uint checksum;
}

// the file has a magic number header, then a bunch of chunks. This wraps
// that up for you - you should never need to pry into the insides of this for
// simple images
struct PNG {
	uint length;
	ubyte[8] header;
	Chunk[] chunks;

	Chunk* getChunk(string what) {
		foreach(ref c; chunks) {
			if(cast(string) c.type == what)
				return &c;
		}
		throw new Exception("no such chunk " ~ what);
	}

	Chunk* getChunkNullable(string what) {
		foreach(ref c; chunks) {
			if(cast(string) c.type == what)
				return &c;
		}
		return null;
	}
}

// Takes a png in memory, and translates it into an array suitable for immediate writing to a file.
// std.file.write("my-image.png", writePng(png));
ubyte[] writePng(PNG* p) {
	ubyte[] a;
	if(p.length)
		a.length = p.length;
	else {
		a.length = 8;
		foreach(c; p.chunks)
			a.length += c.size + 12;
	}
	uint pos;

	a[0..8] = p.header[0..8];
	pos = 8;
	foreach(c; p.chunks) {
		a[pos++] = (c.size & 0xff000000) >> 24;
		a[pos++] = (c.size & 0x00ff0000) >> 16;
		a[pos++] = (c.size & 0x0000ff00) >> 8;
		a[pos++] = (c.size & 0x000000ff) >> 0;

		a[pos..pos+4] = c.type[0..4];
		pos += 4;
		a[pos..pos+c.size] = c.payload[0..c.size];
		pos += c.size;

		a[pos++] = (c.checksum & 0xff000000) >> 24;
		a[pos++] = (c.checksum & 0x00ff0000) >> 16;
		a[pos++] = (c.checksum & 0x0000ff00) >> 8;
		a[pos++] = (c.checksum & 0x000000ff) >> 0;
	}

	return a;
}

// If you just want to handle the data yourself, use this to get a struct ready for addition of other chunks. This function creates the required header chunk based on a struct you pass in.
/*

PNGHeader h;

h.width = desiredWidth;
h.height = desiredHeight;
// the default values of the PNGHeader struct will suffice for everything else. The default is 32 bits per pixel, RGBA - see the source for more info

auto png = blankPNG(h); // creates a PNG* from the given header

addImageDatastreamToPng(pixels, png); // pixels is a ubyte[] representing the raw image data

std.file.write("myimage.png", writePng(png));
*/
PNG* blankPNG(PNGHeader h) {
	auto p = new PNG;
	p.header = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];

	Chunk c;

	c.size = 13;
	c.type = ['I', 'H', 'D', 'R'];

	c.payload.length = 13;
	int pos = 0;

	c.payload[pos++] = h.width >> 24;
	c.payload[pos++] = (h.width >> 16) & 0xff;
	c.payload[pos++] = (h.width >> 8) & 0xff;
	c.payload[pos++] = h.width & 0xff;

	c.payload[pos++] = h.height >> 24;
	c.payload[pos++] = (h.height >> 16) & 0xff;
	c.payload[pos++] = (h.height >> 8) & 0xff;
	c.payload[pos++] = h.height & 0xff;

	c.payload[pos++] = h.depth;
	c.payload[pos++] = h.type;
	c.payload[pos++] = h.compressionMethod;
	c.payload[pos++] = h.filterMethod;
	c.payload[pos++] = h.interlaceMethod;


	c.checksum = crc("IHDR", c.payload);

	p.chunks ~= c;

	return p;
}

// should NOT have any idata already.
// FIXME: doesn't handle palettes

/**Adds a byte array of image data to the given PNG. You are responsible for
 * ensuring that the data array is in the correct format.
 */
void addImageDatastreamToPng(const(ubyte)[] data, PNG* png) {
	// we need to go through the lines and add the filter byte
	// then compress it into an IDAT chunk
	// then add the IEND chunk

	PNGHeader h = getHeader(png);

	auto bytesPerLine = h.width * 4;
	if(h.type == 3)
		bytesPerLine = h.width * 8 /  h.depth;
	Chunk dat;
	dat.type = ['I', 'D', 'A', 'T'];
	int pos = 0;

	const(ubyte)[] output;
	while(pos+bytesPerLine <= data.length) {
		output ~= 0;
		output ~= data[pos..pos+bytesPerLine];
		pos += bytesPerLine;
	}

	auto com = cast(ubyte[]) compress(output);
	dat.size = com.length;
	dat.payload = com;
	dat.checksum = crc("IDAT", dat.payload);

	png.chunks ~= dat;

	Chunk c;

	c.size = 0;
	c.type = ['I', 'E', 'N', 'D'];
	c.checksum = crc("IEND", c.payload);

	png.chunks ~= c;

}

/* CRC function, adapted from example C source in the PNG spec. */

uint update_crc(in uint crc, in ubyte[] buf){
	static immutable uint[256] crc_table =
        [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615,
         3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864,
         162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666,
         4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639,
         325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465,
         4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242,
         1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684,
         3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665,
         651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731,
         3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812,
         795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534,
         2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059,
         2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813,
         2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878,
         1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704,
         2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405,
         1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311,
         2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856,
         1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306,
         3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015,
         1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873,
         3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842,
         3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804,
         225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377,
         4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355,
         426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852,
         4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558,
         953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859,
         3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669,
         829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366,
         3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608,
         733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221,
         2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151,
         1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
         2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610,
         1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567,
         2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745,
         1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938,
         2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836,
         1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897,
         3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203,
         1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724,
         3020668471, 3272380065, 1510334235, 755167117];

	uint c = crc;

	foreach(b; buf)
		c = crc_table[(c ^ b) & 0xff] ^ (c >> 8);

	return c;
}

// lol is just the chunk name
uint crc(in string lol, in ubyte[] buf){
	uint c = update_crc(0xffffffffL, cast(ubyte[]) lol);
	return update_crc(c, buf) ^ 0xffffffffL;
}

}
